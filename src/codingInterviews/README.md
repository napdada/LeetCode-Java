# 剑指Offer(第2版)
[TOC]
## Q3. 数组中重复的数字
​	在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。

```
输入：
[2, 3, 1, 0, 2, 5, 3]
输出：2 或 3 
```

解：

1. 遍历计数 - 遍历 nums[] ，利用 countArray[] 记录数出现的次数。

2. 排序后再找重 - 排序 nums[]，再遍历找到第一个重复数字。

3. **原地交换** - 遍历中，第一次遇到数字 xx 时，将其交换至索引 xx 处，而当第二次遇到数字 xx 时，一定有 nums[x] = x，此时即可得到一组重复数字。

   ![原地交换](/Users/panpan/Documents/Code/DevelopTips/图/LeetCode/原地交换.png)

## Q4. 二维数组中的查找

​	在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

 ```
示例:

现有矩阵 matrix 如下：

[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]

给定 target = 5，返回 true。
给定 target = 20，返回 false。
 ```

解：

1. 暴力求解 O(N + M) - 双重循环遍历整个数组，与所有元素一一比较。

2. **类二叉查找树 O(N + M)** - 将矩阵逆时针旋转 45° ，并将其转化为图形式，发现其类似于二叉搜索树，即对于每个元素，其左分支元素更小、右分支元素更大。从二维数组右上角元素开始与 target 比较，target 大则向下比较， target 小则向左比较。

   ![类二叉搜索树](/Users/panpan/Documents/Code/DevelopTips/图/LeetCode/类二叉搜索树.png)

## Q5. 替换空格

​	请实现一个函数，把字符串 s 中的每个空格替换成"%20"。

```
输入：s = "We are happy."
输出："We%20are%20happy."
```

解：

1. 遍历查找替换 O(N) O(N) - 逐个字符遍历字符串查找空格，字符串不为空格追加到新字符串，为空格追加"%20"。
2. 调用`replace()`
3. **原地修改 O(N) O(1)** - 不使用新字符串来存储，但在 Java Python 中不行，因它们字符串建立后不可改变，在 C++ 中可以通过两个指针来原地修改

## Q6. 从尾到头打印链表

​	输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。

```
输入：head = [1,3,2]
输出：[2,3,1]
```

解：

1. 栈 O(N) O(N) - 先入后出实现从尾到头打印。
2. 递归  O(N) O(N)。