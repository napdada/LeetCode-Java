# 剑指Offer(第2版)
[TOC]
 **注O(N) O(N)：先时间复杂度，再空间复杂度，全文如此。**

## A1. 动态规划DP

1. 状态定义
2. 转移方程
3. 初始化
4. 返回值

## A2. 递归

1. 递推参数
2. 终止条件
3. 递推工作
4. 返回值

## Q3. 数组中重复的数字：遍历计数、排序找重、**原地交换**

​	在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。

```
输入：
[2, 3, 1, 0, 2, 5, 3]
输出：2 或 3 
```

解：

1. 遍历计数 - 遍历 nums[] ，利用 countArray[] 记录数出现的次数。

2. 排序后再找重 - 排序 nums[]，再遍历找到第一个重复数字。

3. **原地交换** - 遍历中，第一次遇到数字 xx 时，将其交换至索引 xx 处，而当第二次遇到数字 xx 时，一定有 nums[x] = x，此时即可得到一组重复数字。

   ![原地交换](/Users/panpan/Documents/Code/DevelopTips/图/LeetCode/《剑指Offer（第2版）》/原地交换.png)

## Q4. 二维数组中的查找：暴力求解、**类二叉查找树**

​	在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

 ```
示例:

现有矩阵 matrix 如下：

[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]

给定 target = 5，返回 true。
给定 target = 20，返回 false。
 ```

解：

1. 暴力求解 O(N + M) - 双重循环遍历整个数组，与所有元素一一比较。

2. **类二叉查找树 O(N + M)** - 将矩阵逆时针旋转 45° ，并将其转化为图形式，发现其类似于二叉搜索树，即对于每个元素，其左分支元素更小、右分支元素更大。从二维数组右上角元素开始与 target 比较，target 大则向下比较， target 小则向左比较。

   ![类二叉搜索树](/Users/panpan/Documents/Code/DevelopTips/图/LeetCode/《剑指Offer（第2版）》/类二叉搜索树.png)

## Q5. 替换空格：遍历替换、**原地修改**

​	请实现一个函数，把字符串 s 中的每个空格替换成"%20"。

```
输入：s = "We are happy."
输出："We%20are%20happy."
```

解：

1. 遍历查找替换 O(N) O(N) - 逐个字符遍历字符串查找空格，字符串不为空格追加到新字符串，为空格追加"%20"。
2. 调用`replace()`
3. **原地修改 O(N) O(1)** - 不使用新字符串来存储，但在 Java Python 中不行，因它们字符串建立后不可改变，在 C++ 中可以通过两个指针来原地修改

## Q6. 从尾到头打印链表：栈、递归

​	输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。

```
输入：head = [1,3,2]
输出：[2,3,1]
```

解：

1. 栈 O(N) O(N)  - 先入后出实现从尾到头打印。
2. 递归  O(N) O(N)。

## Q7. 重建二叉树 - 递归、迭代

​	输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

```
例如，给出

前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]

返回如下的二叉树：

    3
   / \
  9  20
    /  \
   15   7
```

解：

1. **递归 O(N) O(N)**

   > **分治算法解析：**
   >
   > - **递推参数**： 根节点在前序遍历的索引 root 、子树在中序遍历的左边界 left 、子树在中序遍历的右边界 right ；
   >
   > - **终止条件**： 当 left > right ，代表已经越过叶节点，此时返回 nullnull ；
   >
   > - **递推工作**：
   >
   >   1. 建立根节点 node ： 节点值为 preorder[root] ；
   >
   >   2. 划分左右子树： 查找根节点在中序遍历 inorder 中的索引 i ；
   >      为了提升效率，本文使用哈希表 dic 存储中序遍历的值与索引的映射，查找操作的时间复杂度为 O(1)O(1)
   >
   >   3. 构建左右子树： 开启左右子树递归；**几个索引值的确定容易出错！！！**
   >
   >      |        | 根节点索引          | 中序遍历左边界 | **中序遍历右边界** |
   >      | ------ | ------------------- | -------------- | ------------------ |
   >      | 左子树 | root + 1            | left           | i - 1              |
   >      | 右子树 | i - left + root + 1 | i + 1          | right              |
   >
   >      - i - left + root + 1含义为 根节点索引 + 左子树长度 + 1
   >
   > - **返回值**： 回溯返回 node ，作为上一层递归中根节点的左 / 右子节点；

   

2. 迭代 O(N) O(N)，不好理解

   > 对于前序遍历中的任意两个连续节点 uu 和 vv，根据前序遍历的流程，我们可以知道 uu 和 vv 只有两种可能的关系：
   >
   > - vv 是 uu 的左儿子。这是因为在遍历到 uu 之后，下一个遍历的节点就是 uu 的左儿子，即 vv；
   >
   > - uu 没有左儿子，并且 vv 是 uu 的某个祖先节点（或者 uu 本身）的右儿子。
   >
   > 
   >
   > **算法：**
   >
   > - 用一个栈和一个指针辅助进行二叉树的构造。初始时栈中存放了根节点（前序遍历的第一个节点），指针指向中序遍历的第一个节点；
   >
   > - 我们依次枚举前序遍历中除了第一个节点以外的每个节点。如果 index 恰好指向栈顶节点，那么我们不断地弹出栈顶节点并向右移动 index，并将当前节点作为最后一个弹出的节点的右儿子；如果 index 和栈顶节点不同，我们将当前节点作为栈顶节点的左儿子；
   >
   > - 无论是哪一种情况，我们最后都将当前的节点入栈。

## Q9. 用两个栈实现队列：栈

​	用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )

```
示例 1：

输入：
["CQueue","appendTail","deleteHead","deleteHead"]
[[],[3],[],[]]
输出：[null,null,3,-1]

示例 2：

输入：
["CQueue","deleteHead","appendTail","appendTail","deleteHead","deleteHead"]
[[],[],[5],[2],[],[]]
输出：[null,-1,null,null,5,2]
```

解：

1. 一栈负责进，一栈复杂出 O(N) O(N)

## Q10 - I. 斐波那契数列：递归、**动态规划DP**

​	写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：

> F(0) = 0,   F(1) = 1
> F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
> 斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。

​	答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

```
示例 1：

输入：n = 2
输出：1

示例 2：

输入：n = 5
输出：5
```

解：

1. 递归 - 效率低，存在大量重复计算；
2. **动态规划 O(N) O(N)** - 某一项等于前两项之和，用循环依次计算。**【注意！！！】先求余与最后求余返回结果一致，但先求可以防止 int 溢出**

## Q10 - II. 青蛙跳台阶问题：递归、**动态规划DP**

​	一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。

​	答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

```
示例 1：

输入：n = 2
输出：2

示例 2：

输入：n = 7
输出：21

示例 3：

输入：n = 0
输出：1
```

解：

1. 递归

2. 动态规划 

   > 此题就是斐波那契数列的变形（区别在于初始值不一样），设跳上 n 级台阶有 f(n) 种跳法。在所有跳法中，青蛙的最后一步只有两种情况： 跳上 1 级或 2 级台阶。
   >
   > - 当为 1 级台阶： 剩 n-1 个台阶，此情况共有 f(n-1) 种跳法；
   > - 当为 2 级台阶： 剩 n-2 个台阶，此情况共有 f(n-2) 种跳法。
   >
   > f(n) 为以上两种情况之和，即 f(n)=f(n-1)+f(n-2)。

## Q11. 旋转数组的最小数字：遍历寻找、**二分法**

​	把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  

```
示例 1：

输入：[3,4,5,1,2]
输出：1

示例 2：

输入：[2,2,2,0,1]
输出：0
```

解：

1. 遍历直到第一个变小的数 O(N) O(1) - 首先用min记录数组中第一个元素的值，之后便利数组，一一与min比较，第一个比min小的即是结果；

2. **二分法 O(log N) O(1)** - 因为整个数组是由两个非递减数列构成的，所以可以用二分来缩小范围

   1）i = 0, j = length - 1, m = (i + j) / 2；

   2）比较索引为m和j数组元素大小，大于则 i = m + 1，等于则 j--，小于则 j = m（或者调用上述遍历找min）

## Q12. 矩阵中的路径：**DFS+剪枝**

​	请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。

[["a","b","c","e"],
["s","f","c","s"],
["a","d","e","e"]]

​	但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。

```
示例 1：

输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
输出：true

示例 2：

输入：board = [["a","b"],["c","d"]], word = "abcd"
输出：false
```

解：

1. **DFS + 剪枝 O(3^K*MN) O(K)**：

   ![DFS+剪枝](/Users/panpan/Documents/Code/DevelopTips/图/LeetCode/《剑指Offer（第2版）》/DFS+剪枝.png)

   1）DFS暴力遍历矩阵中所有字符串可能性，通过递归先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推；

   2）在搜索中，遇到这条路不可能和目标字符串匹配成功的情况，则立即返回，称可行性剪枝；

   - DFS解析：

     - 递归参数：当前元素在矩阵 board 中的行索引 i 和 j ，当前目标字符在 word 中的索引 k。
     - 终止条件：
       1. 返回 false （满足任一一个）：（1）行或列索引越界 （2）当前矩阵元素与目标字符不同（3）当前矩阵元素已访问
       2. 返回 true：`k = len(word) - 1`，即字符串 word 已全部匹配
     - 递推工作：
       1. 标记当前矩阵元素：将 `board[i][j]`修改为空`'\0'`，代表已访问；
       2. 搜索下一单元格：上右下左；
       3. 还原当前矩阵元素：将 `board[i][j]`还原为初始值；
     - 返回值：是否搜索到目标字符串
     - 时间复杂度 O(3^K*MN)：字符串长度为K，搜索中每个字符有四个方向选
     - 空间复杂度 O(K)：搜索过程中的递归深度不超过K，系统因函数调用累计使用栈空间O(K)

   - ```java
     boolean existPath(char[][] board, String word) {
         char[] wordArray = word.toCharArray();
         for (int i = 0; i < board.length; i++) {
             for (int j = 0; j < board[i].length; j++) {
                 if (dfs(board, wordArray, i, j, 0)) return true;
             }
         }
         return false;
     }
     boolean dfs(char[][] board, char[] word, int i, int j, int k) {
         if (i < 0 || i >= board.length || j < 0 || j >= board[i].length || board[i][j] != word[k]) return false;
         if (k == word.length - 1) return true;
         board[i][j] = '\0';
         boolean result = dfs(board, word, i, j - 1, k + 1) || dfs(board, word, i + 1, j, k + 1) ||
                 dfs(board, word, i, j + 1, k + 1) || dfs(board, word, i - 1, j, k + 1);
         board[i][j] = word[k];
         return result;
     }
     ```

## Q13. 机器人的运动范围：DFS（**数位和增量公式、可达性分析）**、BFS

​	地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？

```
示例 1：

输入：m = 2, n = 3, k = 1
输出：3

示例 2：

输入：m = 3, n = 1, k = 0
输出：1
```

解：

1. 深度优先遍历DFS O(MN) O(MN)

   - **数位和增量公式：不需要每次都用整除和求余去计算位数和**

     ![数位和增量公式](/Users/panpan/Documents/Code/DevelopTips/图/LeetCode/《剑指Offer（第2版）》/数位和增量公式.png)

   - 可达解分析：**仅需向右、向下移动**

   - 与Q12类似，采用递归求解即可，代码十分类似

2. 广度优先遍历BFS O(MN) O(MN)

   - 用队列实现：

     1）将机器人初始点加入队列；

     2）将队首单元格的索引、数位弹出；

     3）判断是否越界或超出k或已访问；

     4）对未访问的单元格进行标记，(i, j )存入visited中；

     5）将当前元素的下方、右方单元格数位入队；

     6）队列为空时，停止迭代

## Q14 - I. 剪绳子：**数学推导、贪心、动态规划**

​	给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0]*k[1]*...*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。

```
示例 1：

输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1

示例 2:

输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36
```

解：

1. **数学推导 O(1) O(1)**

   - 由重要不等式的推论可以证明，绳子越等分乘积越大；

   - 求导也可以证明，同时可以求得驻点为e，即2.7左右，通过带入2、3可以得到绳子越多切分成长度3，乘积越大；

     ![绳子切分](/Users/panpan/Documents/Code/DevelopTips/图/LeetCode/《剑指Offer（第2版）》/绳子切分.png)

   - 那么转换成以下算法：

     1）3a + b = n，当 n <= 3 时，由于 m > 1，那么必须有一段绳子长度为1，乘积即为 n - 1；

     2）当 n > 3 时，对 b 讨论，即 n % 3 讨论：b = 0 时，乘积为 3 ^ a；b = 1 时，乘积为 3 ^ （a - 1） * 4，即有一段长度为3的绳子要拿出来和长度为1的绳子形成2 + 2；b = 2 时，乘积为 3 ^ a * 2；

2. **贪心**

   - ![绳子切分贪心](/Users/panpan/Documents/Code/DevelopTips/图/LeetCode/《剑指Offer（第2版）》/绳子切分贪心.png)

3. 动态规划 O(N^2) O(N)

   - ![绳子切分动态规划](/Users/panpan/Documents/Code/DevelopTips/图/LeetCode/《剑指Offer（第2版）》/绳子切分动态规划.png)

   - ```java
     class Solution {
         public int cuttingRope(int n) {
             int[] dp = new int[n + 1];
             dp[2] = 1;
             for(int i = 3; i < n + 1; i++){
                 for(int j = 2; j < i; j++){
                     dp[i] = Math.max(dp[i], Math.max(j * (i - j), j * dp[i - j]));
                 }
             }
             return dp[n];
         }
     }
     ```

## Q14 - II. 剪绳子 II：循环求余、**快速求余**

​	给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m - 1] 。请问 k[0]*k[1]*...*k[m - 1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。

​	答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

```
示例 1：

输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1

示例 2:

输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36
```

解（此题跟上一题差别在于n的范围）：

1. 循环求余 O(N) O(1) - 每一次幂运算都求一次余数；

2. **快速求余 O(log2 N) O(1)**

   - ![快速幂求余](/Users/panpan/Documents/Code/DevelopTips/图/LeetCode/《剑指Offer（第2版）》/快速幂求余.png)

   - ```java
     class Solution {
         public int cuttingRope(int n) {
             if(n <= 3) return n - 1;
             int b = n % 3, p = 1000000007;
             long rem = 1, x = 3;
             for(int a = n / 3 - 1; a > 0; a /= 2) {
                 if(a % 2 == 1) rem = (rem * x) % p;
                 x = (x * x) % p;
             }
             if(b == 0) return (int)(rem * 3 % p);
             if(b == 1) return (int)(rem * 4 % p);
             return (int)(rem * 6 % p);
         }
     }
     ```

## Q15. 二进制中1的个数：**巧用n & (n - 1)**、逐位判断

​	请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。

```
示例 1：

输入：00000000000000000000000000001011
输出：3
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。

示例 2：

输入：00000000000000000000000010000000
输出：1
解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。

示例 3：

输入：11111111111111111111111111111101
输出：31
解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。
```

解：

1. **巧用 n & (n - 1) O(M) O(1)**，M 为 1 的个数。
   - (n−1) 解析： 二进制数字 n 最右边的 1 变成 0 ，此 1 右边的 0 都变成 1 。
   - n \& (n - 1)解析： 二进制数字 n 最右边的 1 变成 0 ，其余不变。
2. 逐位判断 O(log2 N) O(1) - 将 n 和 1 做与操作，结果为 1 时计数，再将 n 向右移位重复操作。

## Q16. 数值的整数次方：循环求幂、**二进制快速幂**、**二分法快速幂**

​	实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题。

```
示例 1：

输入：x = 2.00000, n = 10
输出：1024.00000
示例 2：

输入：x = 2.10000, n = 3
输出：9.26100
示例 3：

输入：x = 2.00000, n = -2
输出：0.25000
解释：2-2 = 1/22 = 1/4 = 0.25
```

解：

1. 循环求解 O(N) O(1) - 用循环一次次累乘，以求幂运算；

2. **二进制快速幂 O(log2 N) O(1)** - 利用十进制数字 n 的二进制表示，可对快速幂进行数学化解释。

   ![二进制快速幂](/Users/panpan/Documents/Code/DevelopTips/图/算法/二进制快速幂.png)

3. **二分法快速幂 O(log2 N) O(1)** - 与上个方法类似

   ![二分法快速幂](/Users/panpan/Documents/Code/DevelopTips/图/算法/二分法快速幂.png)

## Q17. 打印从1到最大的n位数：循环打印、**大数打印（递归）**

​	输入数字 `n`，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。

```
示例 1:

输入: n = 1
输出: [1,2,3,4,5,6,7,8,9]
```

解：

1. 循环打印 O(10^N) O(1)（ 列表作为返回结果，不计入额外空间 ） - 直接构建数组循环输出。

2. 大数打印 O(10^N) O(10^N) - 题目给定了 int 范围，但实际情况可能会考大数，这时候用 int 无法解，需要用 String。

   - ![大数递归打印](/Users/panpan/Documents/Code/DevelopTips/图/LeetCode/《剑指Offer（第2版）》/大数递归打印.png)

   - 主要处理两个问题：

     1. 删除高位多余的 0：

        ![删除高位0](/Users/panpan/Documents/Code/DevelopTips/图/LeetCode/《剑指Offer（第2版）》/删除高位0.png)

     2. 列表从 1 开始：添加字符串前判断是否为“0”，是则跳过。

## Q18. 删除链表的节点：遍历对比删除

​	给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。返回删除后的链表的头节点。

```
示例 1:

输入: head = [4,5,1,9], val = 5
输出: [4,1,9]
解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.

示例 2:

输入: head = [4,5,1,9], val = 1
输出: [4,5,9]
解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 5 -> 9.
```

解：

1. 遍历对比删除 O(N) O(1) - 从头节点开始依次比较，找到要删除的节点进行删除，即将上一个节点指向下一个节点。

## Q19. 正则表达式匹配：**动态规划**

​	请实现一个函数用来匹配包含 . 和 * 的正则表达式。模式中的字符 . 表示任意一个字符，而 * 表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串"aaa"与模式"a.a"和"ab * ac * a"匹配，但与"aa.a"和"ab*a"均不匹配。

```
示例 1:

输入:
s = "aa"
p = "a"
输出: false
解释: "a" 无法匹配 "aa" 整个字符串。

示例 2:

输入:
s = "aa"
p = "a*"
输出: true
解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。

示例 3:

输入:
s = "ab"
p = ".*"
输出: true
解释: ".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。

示例 4:

输入:
s = "aab"
p = "c*a*b"
输出: true
解释: 因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 "aab"。

示例 5:

输入:
s = "mississippi"
p = "mis*is*p*."
输出: false
```

解：

1. **动态规划 O(NM) O(NM)**
   - 总体思路：每轮添加一个字符并判断是否能匹配，直至添加完整个字符串 s 和 p。
   - ![正则表达式匹配](/Users/panpan/Documents/Code/DevelopTips/图/LeetCode/《剑指Offer（第2版）》/正则表达式匹配.png)
   - ![正则表达式匹配DP](/Users/panpan/Documents/Code/DevelopTips/图/LeetCode/《剑指Offer（第2版）》/正则表达式匹配DP.png)

## Q20. 表示数值的字符串

​	请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串"+100"、"5e2"、"-123"、"3.1416"、"-1E-16"、"0123"都表示数值，但"12e"、"1a3.14"、"1.2.3"、"+-5"及"12e+5.4"都不是。

解：

1. 遍历判断 O(N) O(1) - 逐位遍历判断是否符合数字要求

   - '.'出现正确的情况：只出现一次，且在e/E前；

   - 'e/E'出现正确的情况：只出现一次，且出现前有数字；

   - '+/-'出现正确的情况：只能在开头或者e/E后一位；

   - ```java
     public static boolean isNumber(String s) {
         boolean hasNum = false, hasDecimal = false, hasE = false; // 是否有数字、小数、e/E
         s = s.trim(); // 删除前后多余空格
         for (int i = 0; i < s.length(); i++) {
             if (s.charAt(i) >= '0' && s.charAt(i) <= '9') hasNum = true;
             else if (s.charAt(i) == '.' && !hasDecimal && !hasE) {
                 hasDecimal = true;
             } else if ((s.charAt(i) == 'e' || s.charAt(i) == 'E') && !hasE && hasNum){
                 hasE = true;
                 hasNum = false;
             } else if ((s.charAt(i) == '+' || s.charAt(i) == '-') && (i == 0 || s.charAt(i - 1) == 'e' || s.charAt(i - 1) == 'E')) {
     
             } else {
                 return false;
             }
         }
         return hasNum;
     }
     ```

2. 有限状态自动机 O(N) O(1) 

   - ![判断数字有限状态自动机](/Users/panpan/Documents/Code/DevelopTips/图/LeetCode/《剑指Offer（第2版）》/判断数字有限状态自动机.png)

   - ```java
     class Solution {
         public boolean isNumber(String s) {
             Map[] states = {
                 new HashMap<>() {{ put(' ', 0); put('s', 1); put('d', 2); put('.', 4); }}, // 0.
                 new HashMap<>() {{ put('d', 2); put('.', 4); }},                           // 1.
                 new HashMap<>() {{ put('d', 2); put('.', 3); put('e', 5); put(' ', 8); }}, // 2.
                 new HashMap<>() {{ put('d', 3); put('e', 5); put(' ', 8); }},              // 3.
                 new HashMap<>() {{ put('d', 3); }},                                        // 4.
                 new HashMap<>() {{ put('s', 6); put('d', 7); }},                           // 5.
                 new HashMap<>() {{ put('d', 7); }},                                        // 6.
                 new HashMap<>() {{ put('d', 7); put(' ', 8); }},                           // 7.
                 new HashMap<>() {{ put(' ', 8); }}                                         // 8.
             };
             int p = 0;
             char t;
             for(char c : s.toCharArray()) {
                 if(c >= '0' && c <= '9') t = 'd';
                 else if(c == '+' || c == '-') t = 's';
                 else if(c == 'e' || c == 'E') t = 'e';
                 else if(c == '.' || c == ' ') t = c;
                 else t = '?';
                 if(!states[p].containsKey(t)) return false;
                 p = (int)states[p].get(t);
             }
             return p == 2 || p == 3 || p == 7 || p == 8;
         }
     }
     ```

## Q21. 调整数组顺序使奇数位于偶数前面：遍历找奇偶并用数组存储、**双指针交换**

​	输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。

```
示例：

输入：nums = [1,2,3,4]
输出：[1,3,2,4] 
注：[3,1,2,4] 也是正确的答案之一。
```

解：

1. 遍历找奇偶并用数组存储 O(N) O(N) - 遍历数组，用两个指针指向新数组头尾，遇到奇数往头部放，遇到偶数往尾部放。
2. 双指针交换 O(N) O(1) - 一头一尾指针指向原数组，头指针为奇数时右移，尾指针为偶数时左移，找到第一个不满足条件的两个值交换，然后继续循环。



