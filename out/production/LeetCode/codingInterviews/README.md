# 剑指Offer(第2版)
[TOC]
 **注O(N) O(N)：先时间复杂度，再空间复杂度，全文如此。**

## Q3. 数组中重复的数字：遍历计数、排序找重、**原地交换**

​	在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。

```
输入：
[2, 3, 1, 0, 2, 5, 3]
输出：2 或 3 
```

解：

1. 遍历计数 - 遍历 nums[] ，利用 countArray[] 记录数出现的次数。

2. 排序后再找重 - 排序 nums[]，再遍历找到第一个重复数字。

3. **原地交换** - 遍历中，第一次遇到数字 xx 时，将其交换至索引 xx 处，而当第二次遇到数字 xx 时，一定有 nums[x] = x，此时即可得到一组重复数字。

   ![原地交换](/Users/panpan/Documents/Code/DevelopTips/图/LeetCode/原地交换.png)

## Q4. 二维数组中的查找：暴力求解、**类二叉查找树**

​	在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

 ```
示例:

现有矩阵 matrix 如下：

[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]

给定 target = 5，返回 true。
给定 target = 20，返回 false。
 ```

解：

1. 暴力求解 O(N + M) - 双重循环遍历整个数组，与所有元素一一比较。

2. **类二叉查找树 O(N + M)** - 将矩阵逆时针旋转 45° ，并将其转化为图形式，发现其类似于二叉搜索树，即对于每个元素，其左分支元素更小、右分支元素更大。从二维数组右上角元素开始与 target 比较，target 大则向下比较， target 小则向左比较。

   ![类二叉搜索树](/Users/panpan/Documents/Code/DevelopTips/图/LeetCode/类二叉搜索树.png)

## Q5. 替换空格：遍历替换、**原地修改**

​	请实现一个函数，把字符串 s 中的每个空格替换成"%20"。

```
输入：s = "We are happy."
输出："We%20are%20happy."
```

解：

1. 遍历查找替换 O(N) O(N) - 逐个字符遍历字符串查找空格，字符串不为空格追加到新字符串，为空格追加"%20"。
2. 调用`replace()`
3. **原地修改 O(N) O(1)** - 不使用新字符串来存储，但在 Java Python 中不行，因它们字符串建立后不可改变，在 C++ 中可以通过两个指针来原地修改

## Q6. 从尾到头打印链表：栈、递归

​	输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。

```
输入：head = [1,3,2]
输出：[2,3,1]
```

解：

1. 栈 O(N) O(N)  - 先入后出实现从尾到头打印。
2. 递归  O(N) O(N)。

## Q7. 重建二叉树 - 递归、迭代

​	输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

```
例如，给出

前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]

返回如下的二叉树：

    3
   / \
  9  20
    /  \
   15   7
```

解：

1. 递归 O(N) O(N)

   > **分治算法解析：**
   >
   > - **递推参数**： 根节点在前序遍历的索引 root 、子树在中序遍历的左边界 left 、子树在中序遍历的右边界 right ；
   >
   > - **终止条件**： 当 left > right ，代表已经越过叶节点，此时返回 nullnull ；
   >
   > - **递推工作**：
   >
   >   1. 建立根节点 node ： 节点值为 preorder[root] ；
   >
   >   2. 划分左右子树： 查找根节点在中序遍历 inorder 中的索引 i ；
   >      为了提升效率，本文使用哈希表 dic 存储中序遍历的值与索引的映射，查找操作的时间复杂度为 O(1)O(1)
   >
   >   3. 构建左右子树： 开启左右子树递归；**几个索引值的确定容易出错！！！**
   >
   >      |        | 根节点索引          | 中序遍历左边界 | **中序遍历右边界** |
   >      | ------ | ------------------- | -------------- | ------------------ |
   >      | 左子树 | root + 1            | left           | i - 1              |
   >      | 右子树 | i - left + root + 1 | i + 1          | right              |
   >
   >      - i - left + root + 1含义为 根节点索引 + 左子树长度 + 1
   >
   > - **返回值**： 回溯返回 node ，作为上一层递归中根节点的左 / 右子节点；

   

2. 迭代 O(N) O(N)，不好理解

   > 对于前序遍历中的任意两个连续节点 uu 和 vv，根据前序遍历的流程，我们可以知道 uu 和 vv 只有两种可能的关系：
   >
   > - vv 是 uu 的左儿子。这是因为在遍历到 uu 之后，下一个遍历的节点就是 uu 的左儿子，即 vv；
   >
   > - uu 没有左儿子，并且 vv 是 uu 的某个祖先节点（或者 uu 本身）的右儿子。
   >
   > 
   >
   > **算法：**
   >
   > - 用一个栈和一个指针辅助进行二叉树的构造。初始时栈中存放了根节点（前序遍历的第一个节点），指针指向中序遍历的第一个节点；
   >
   > - 我们依次枚举前序遍历中除了第一个节点以外的每个节点。如果 index 恰好指向栈顶节点，那么我们不断地弹出栈顶节点并向右移动 index，并将当前节点作为最后一个弹出的节点的右儿子；如果 index 和栈顶节点不同，我们将当前节点作为栈顶节点的左儿子；
   >
   > - 无论是哪一种情况，我们最后都将当前的节点入栈。

## Q9. 用两个栈实现队列：栈

​	用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )

```
示例 1：

输入：
["CQueue","appendTail","deleteHead","deleteHead"]
[[],[3],[],[]]
输出：[null,null,3,-1]

示例 2：

输入：
["CQueue","deleteHead","appendTail","appendTail","deleteHead","deleteHead"]
[[],[],[5],[2],[],[]]
输出：[null,-1,null,null,5,2]
```

解：

1. 一栈负责进，一栈复杂出 O(N) O(N)

## Q10 - I. 斐波那契数列：递归、**动态规划DP**

​	写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：

> F(0) = 0,   F(1) = 1
> F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
> 斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。

​	答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

```
示例 1：

输入：n = 2
输出：1

示例 2：

输入：n = 5
输出：5
```

解：

1. 递归 - 效率低，存在大量重复计算；
2. 动态规划 O(N) O(N) - 某一项等于前两项之和，用循环依次计算。**【注意！！！】先求余与最后求余返回结果一致，但先求可以防止 int 溢出**

## Q10 - II. 青蛙跳台阶问题：递归、**动态规划DP**

​	一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。

​	答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

```
示例 1：

输入：n = 2
输出：2

示例 2：

输入：n = 7
输出：21

示例 3：

输入：n = 0
输出：1
```

解：

1. 递归

2. 动态规划 

   > 此题就是斐波那契数列的变形（区别在于初始值不一样），设跳上 n 级台阶有 f(n) 种跳法。在所有跳法中，青蛙的最后一步只有两种情况： 跳上 1 级或 2 级台阶。
   >
   > - 当为 1 级台阶： 剩 n-1 个台阶，此情况共有 f(n-1) 种跳法；
   > - 当为 2 级台阶： 剩 n-2 个台阶，此情况共有 f(n-2) 种跳法。
   >
   > f(n) 为以上两种情况之和，即 f(n)=f(n-1)+f(n-2)。

## Q11. 旋转数组的最小数字：遍历寻找、**二分法**

​	把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  

```
示例 1：

输入：[3,4,5,1,2]
输出：1

示例 2：

输入：[2,2,2,0,1]
输出：0
```

解：

1. 遍历直到第一个变小的数 O(N) O(1) - 首先用min记录数组中第一个元素的值，之后便利数组，一一与min比较，第一个比min小的即是结果；

2. 二分法 O(log N) O(1) - 因为整个数组是由两个非递减数列构成的，所以可以用二分来缩小范围

   1）i = 0, j = length - 1, m = (i + j) / 2；

   2）比较索引为m和j数组元素大小，大于则 i = m + 1，等于则 j--，小于则 j = m（或者调用上述遍历找min）

## Q12. 矩阵中的路径：**DFS+剪枝**

​	请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。

[["a","b","c","e"],
["s","f","c","s"],
["a","d","e","e"]]

​	但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。

```
示例 1：

输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
输出：true

示例 2：

输入：board = [["a","b"],["c","d"]], word = "abcd"
输出：false
```

解：

1. DFS + 剪枝 O(3^K*MN) O(K)：

   ![DFS+剪枝](/Users/panpan/Documents/Code/DevelopTips/图/LeetCode/DFS+剪枝.png)

   1）DFS暴力遍历矩阵中所有字符串可能性，通过递归先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推；

   2）在搜索中，遇到这条路不可能和目标字符串匹配成功的情况，则立即返回，称可行性剪枝；

   - DFS解析：

     - 递归参数：当前元素在矩阵 board 中的行索引 i 和 j ，当前目标字符在 word 中的索引 k。
     - 终止条件：
       1. 返回 false （满足任一一个）：（1）行或列索引越界 （2）当前矩阵元素与目标字符不同（3）当前矩阵元素已访问
       2. 返回 true：`k = len(word) - 1`，即字符串 word 已全部匹配
     - 递推工作：
       1. 标记当前矩阵元素：将 `board[i][j]`修改为空`'\0'`，代表已访问；
       2. 搜索下一单元格：上右下左；
       3. 还原当前矩阵元素：将 `board[i][j]`还原为初始值；
     - 返回值：是否搜索到目标字符串
     - 时间复杂度 O(3^K*MN)：字符串长度为K，搜索中每个字符有四个方向选
     - 空间复杂度 O(K)：搜索过程中的递归深度不超过K，系统因函数调用累计使用栈空间O(K)

   - ```java
     boolean existPath(char[][] board, String word) {
         char[] wordArray = word.toCharArray();
         for (int i = 0; i < board.length; i++) {
             for (int j = 0; j < board[i].length; j++) {
                 if (dfs(board, wordArray, i, j, 0)) return true;
             }
         }
         return false;
     }
     boolean dfs(char[][] board, char[] word, int i, int j, int k) {
         if (i < 0 || i >= board.length || j < 0 || j >= board[i].length || board[i][j] != word[k]) return false;
         if (k == word.length - 1) return true;
         board[i][j] = '\0';
         boolean result = dfs(board, word, i, j - 1, k + 1) || dfs(board, word, i + 1, j, k + 1) ||
                 dfs(board, word, i, j + 1, k + 1) || dfs(board, word, i - 1, j, k + 1);
         board[i][j] = word[k];
         return result;
     }
     ```

## Q13. 机器人的运动范围：DFS（**数位和增量公式、可达性分析）**、BFS

​	地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？

```
示例 1：

输入：m = 2, n = 3, k = 1
输出：3

示例 2：

输入：m = 3, n = 1, k = 0
输出：1
```

解：

1. 深度优先遍历DFS O(MN) O(MN)

   - **数位和增量公式：不需要每次都用整除和求余去计算位数和**

     ![数位和增量公式](/Users/panpan/Documents/Code/DevelopTips/图/LeetCode/数位和增量公式.png)

   - 可达解分析：**仅需向右、向下移动**

   - 与Q12类似，采用递归求解即可，代码十分类似

2. 广度优先遍历BFS O(MN) O(MN)

   - 用队列实现：

     1）将机器人初始点加入队列；

     2）将队首单元格的索引、数位弹出；

     3）判断是否越界或超出k或已访问；

     4）对未访问的单元格进行标记，(i, j )存入visited中；

     5）将当前元素的下方、右方单元格数位入队；

     6）队列为空时，停止迭代

## Q14 - I. 剪绳子：**数学推导、贪心、动态规划**

​	给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0]*k[1]*...*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。

```
示例 1：

输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1

示例 2:

输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36
```

解：

1. **数学推导 O(1) O(1)**

   - 由重要不等式的推论可以证明，绳子越等分乘积越大；

   - 求导也可以证明，同时可以求得驻点为e，即2.7左右，通过带入2、3可以得到绳子越多切分成长度3，乘积越大；

     ![绳子切分](/Users/panpan/Documents/Code/DevelopTips/图/LeetCode/绳子切分.png)

   - 那么转换成以下算法：

     1）3a + b = n，当 n <= 3 时，由于 m > 1，那么必须有一段绳子长度为1，乘积即为 n - 1；

     2）当 n > 3 时，对 b 讨论，即 n % 3 讨论：b = 0 时，乘积为 3 ^ a；b = 1 时，乘积为 3 ^ （a - 1） * 4，即有一段长度为3的绳子要拿出来和长度为1的绳子形成2 + 2；b = 2 时，乘积为 3 ^ a * 2；

2. **贪心**

   - ![绳子切分贪心](/Users/panpan/Documents/Code/DevelopTips/图/LeetCode/绳子切分贪心.png)

3. 动态规划 O(N^2) O(N)

   - ![绳子切分动态规划](/Users/panpan/Documents/Code/DevelopTips/图/LeetCode/绳子切分动态规划.png)

   - ```java
     class Solution {
         public int cuttingRope(int n) {
             int[] dp = new int[n + 1];
             dp[2] = 1;
             for(int i = 3; i < n + 1; i++){
                 for(int j = 2; j < i; j++){
                     dp[i] = Math.max(dp[i], Math.max(j * (i - j), j * dp[i - j]));
                 }
             }
             return dp[n];
         }
     }
     ```

## Q14 - II. 剪绳子 II：

​	给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m - 1] 。请问 k[0]*k[1]*...*k[m - 1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。

​	答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

```
示例 1：

输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1

示例 2:

输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36
```









