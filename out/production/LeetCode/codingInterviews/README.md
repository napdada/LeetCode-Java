# 剑指Offer(第2版)
[TOC]
 **注O(N) O(N)：先时间复杂度，再空间复杂度，全文如此。**

## Q3. 数组中重复的数字

​	在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。

```
输入：
[2, 3, 1, 0, 2, 5, 3]
输出：2 或 3 
```

解：

1. 遍历计数 - 遍历 nums[] ，利用 countArray[] 记录数出现的次数。

2. 排序后再找重 - 排序 nums[]，再遍历找到第一个重复数字。

3. **原地交换** - 遍历中，第一次遇到数字 xx 时，将其交换至索引 xx 处，而当第二次遇到数字 xx 时，一定有 nums[x] = x，此时即可得到一组重复数字。

   ![原地交换](/Users/panpan/Documents/Code/DevelopTips/图/LeetCode/原地交换.png)

## Q4. 二维数组中的查找

​	在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

 ```
示例:

现有矩阵 matrix 如下：

[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]

给定 target = 5，返回 true。
给定 target = 20，返回 false。
 ```

解：

1. 暴力求解 O(N + M) - 双重循环遍历整个数组，与所有元素一一比较。

2. **类二叉查找树 O(N + M)** - 将矩阵逆时针旋转 45° ，并将其转化为图形式，发现其类似于二叉搜索树，即对于每个元素，其左分支元素更小、右分支元素更大。从二维数组右上角元素开始与 target 比较，target 大则向下比较， target 小则向左比较。

   ![类二叉搜索树](/Users/panpan/Documents/Code/DevelopTips/图/LeetCode/类二叉搜索树.png)

## Q5. 替换空格

​	请实现一个函数，把字符串 s 中的每个空格替换成"%20"。

```
输入：s = "We are happy."
输出："We%20are%20happy."
```

解：

1. 遍历查找替换 O(N) O(N) - 逐个字符遍历字符串查找空格，字符串不为空格追加到新字符串，为空格追加"%20"。
2. 调用`replace()`
3. **原地修改 O(N) O(1)** - 不使用新字符串来存储，但在 Java Python 中不行，因它们字符串建立后不可改变，在 C++ 中可以通过两个指针来原地修改

## Q6. 从尾到头打印链表

​	输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。

```
输入：head = [1,3,2]
输出：[2,3,1]
```

解：

1. 栈 O(N) O(N)  - 先入后出实现从尾到头打印。
2. 递归  O(N) O(N)。

## Q7. 重建二叉树

​	输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

```
例如，给出

前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]

返回如下的二叉树：

    3
   / \
  9  20
    /  \
   15   7
```

解：

1. 递归 O(N) O(N)

   > **分治算法解析：**
   >
   > - **递推参数**： 根节点在前序遍历的索引 root 、子树在中序遍历的左边界 left 、子树在中序遍历的右边界 right ；
   >
   > - **终止条件**： 当 left > right ，代表已经越过叶节点，此时返回 nullnull ；
   >
   > - **递推工作**：
   >
   >   1. 建立根节点 node ： 节点值为 preorder[root] ；
   >
   >   2. 划分左右子树： 查找根节点在中序遍历 inorder 中的索引 i ；
   >      为了提升效率，本文使用哈希表 dic 存储中序遍历的值与索引的映射，查找操作的时间复杂度为 O(1)O(1)
   >
   >   3. 构建左右子树： 开启左右子树递归；**几个索引值的确定容易出错！！！**
   >
   >      |        | 根节点索引          | 中序遍历左边界 | **中序遍历右边界** |
   >      | ------ | ------------------- | -------------- | ------------------ |
   >      | 左子树 | root + 1            | left           | i - 1              |
   >      | 右子树 | i - left + root + 1 | i + 1          | right              |
   >
   >      - i - left + root + 1含义为 根节点索引 + 左子树长度 + 1
   >
   > - **返回值**： 回溯返回 node ，作为上一层递归中根节点的左 / 右子节点；

   

2. 迭代 O(N) O(N)，不好理解

   > 对于前序遍历中的任意两个连续节点 uu 和 vv，根据前序遍历的流程，我们可以知道 uu 和 vv 只有两种可能的关系：
   >
   > - vv 是 uu 的左儿子。这是因为在遍历到 uu 之后，下一个遍历的节点就是 uu 的左儿子，即 vv；
   >
   > - uu 没有左儿子，并且 vv 是 uu 的某个祖先节点（或者 uu 本身）的右儿子。
   >
   > 
   >
   > **算法：**
   >
   > - 用一个栈和一个指针辅助进行二叉树的构造。初始时栈中存放了根节点（前序遍历的第一个节点），指针指向中序遍历的第一个节点；
   >
   > - 我们依次枚举前序遍历中除了第一个节点以外的每个节点。如果 index 恰好指向栈顶节点，那么我们不断地弹出栈顶节点并向右移动 index，并将当前节点作为最后一个弹出的节点的右儿子；如果 index 和栈顶节点不同，我们将当前节点作为栈顶节点的左儿子；
   >
   > - 无论是哪一种情况，我们最后都将当前的节点入栈。

## Q9. 用两个栈实现队列

​	用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )

```
示例 1：

输入：
["CQueue","appendTail","deleteHead","deleteHead"]
[[],[3],[],[]]
输出：[null,null,3,-1]

示例 2：

输入：
["CQueue","deleteHead","appendTail","appendTail","deleteHead","deleteHead"]
[[],[],[5],[2],[],[]]
输出：[null,-1,null,null,5,2]
```

解：

1. 一栈负责进，一栈复杂出 O(N) O(N)

## Q10 - I. 斐波那契数列

​	写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：

> F(0) = 0,   F(1) = 1
> F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
> 斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。

​	答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

```
示例 1：

输入：n = 2
输出：1

示例 2：

输入：n = 5
输出：5
```

解：

1. 递归 - 效率低，存在大量重复计算；
2. 动态规划 O(N) O(N) - 某一项等于前两项之和，用循环依次计算。**【注意！！！】先求余与最后求余返回结果一致，但先求可以防止 int 溢出**

## Q10 - II. 青蛙跳台阶问题

​	一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。

​	答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

```
示例 1：

输入：n = 2
输出：2

示例 2：

输入：n = 7
输出：21

示例 3：

输入：n = 0
输出：1
```

解：

1. 递归

2. 动态规划 

   > 此题就是斐波那契数列的变形（区别在于初始值不一样），设跳上 n 级台阶有 f(n) 种跳法。在所有跳法中，青蛙的最后一步只有两种情况： 跳上 1 级或 2 级台阶。
   >
   > - 当为 1 级台阶： 剩 n-1 个台阶，此情况共有 f(n-1) 种跳法；
   > - 当为 2 级台阶： 剩 n-2 个台阶，此情况共有 f(n-2) 种跳法。
   >
   > f(n) 为以上两种情况之和，即 f(n)=f(n-1)+f(n-2)。

## Q11. 旋转数组的最小数字

​	把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  

```
示例 1：

输入：[3,4,5,1,2]
输出：1

示例 2：

输入：[2,2,2,0,1]
输出：0
```

解：

1. 遍历直到第一个变小的数 O(N) O(1) - 首先用min记录数组中第一个元素的值，之后便利数组，一一与min比较，第一个比min小的即是结果；

2. 二分法 O(log N) O(1) - 因为整个数组是由两个非递减数列构成的，所以可以用二分来缩小范围

   1）i = 0, j = length - 1, m = (i + j) / 2；

   2）比较索引为m和j数组元素大小，大于则 i = m + 1，等于则 j--，小于则 j = m（或者调用上述遍历找min）

## Q12. 矩阵中的路径

​	请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。

[["a","b","c","e"],
["s","f","c","s"],
["a","d","e","e"]]

​	但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。

```
示例 1：

输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
输出：true

示例 2：

输入：board = [["a","b"],["c","d"]], word = "abcd"
输出：false
```

